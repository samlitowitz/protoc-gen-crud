// REFURL: https://github.com/grpc-ecosystem/grpc-gateway/blob/main/protoc-gen-grpc-gateway/internal/gengateway/template.go
package crud

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"

	"github.com/samlitowitz/protoc-gen-crud/internal/casing"
	"github.com/samlitowitz/protoc-gen-crud/internal/descriptor"
)

func init() {
	strcase.ConfigureAcronym("UID", "uid")
}

type param struct {
	*descriptor.File
	Imports []descriptor.GoPackage
}

type field struct {
	Def  *descriptor.Field
	Hash string
}

type crud struct {
	*descriptor.CRUD
	Registry *descriptor.Registry

	fieldByFieldConstants map[string]*field
}

func (crud *crud) FieldByFieldConstants() map[string]*field {
	if crud.fieldByFieldConstants != nil {
		return crud.fieldByFieldConstants
	}

	crud.fieldByFieldConstants = make(map[string]*field)
	for _, fieldDef := range crud.CRUD.Fields {
		name := fmt.Sprintf(
			"%s_%s_Field",
			strcase.ToCamel(crud.CRUD.GetName()),
			strcase.ToCamel(fieldDef.GetName()),
		)
		if fieldDef.HasRelationship() {
			minUIDFields := fieldDef.Relationship.CRUD.MinimalUIDFields()
			if len(minUIDFields) != 1 {
				panic(fmt.Errorf("message type must have unique identifier with exactly one field defined on field %s", fieldDef.GetName()))
			}
			name = fmt.Sprintf(
				"%s_%s_Id_Field",
				strcase.ToCamel(crud.CRUD.GetName()),
				strcase.ToCamel(fieldDef.GetName()),
			)
		}

		h := sha256.New()
		_, err := h.Write([]byte(name))
		if err != nil {
			panic(err)
		}
		crud.fieldByFieldConstants[name] = &field{
			Def:  fieldDef,
			Hash: hex.EncodeToString(h.Sum(nil)),
		}
	}
	return crud.fieldByFieldConstants
}

func applyTemplate(p param, reg *descriptor.Registry) (string, error) {
	w := bytes.NewBuffer(nil)
	if err := headerTemplate.Execute(w, p); err != nil {
		return "", err
	}

	for _, msg := range p.Messages {
		msgName := casing.Camel(*msg.Name)
		msg.Name = &msgName
	}
	for _, def := range p.CRUDs {
		inject := &crud{
			CRUD:     def,
			Registry: reg,
		}
		if err := repositoryTemplate.Execute(w, inject); err != nil {
			return "", nil
		}
	}

	return w.String(), nil
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: {{.GetName}}

/*
Package {{.GoPkg.Name}} is a repository.

It provides an interface to implement.
*/

package {{.GoPkg.Name}}
{{if .Imports}}
import (
	{{range $i := .Imports}}{{if $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}

	{{range $i := .Imports}}{{if not $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}
)
{{end}}
`))

	repositoryTemplate = template.Must(template.New("repository").Parse(`
{{if .CRUD.Read}}
{{if .FieldByFieldConstants}}
const (
{{- range $name, $data := .FieldByFieldConstants}}
	{{$name}} expressions.FieldID = "{{$data.Hash}}"
{{- end}}
)
{{end}}
var valid{{.CRUD.Name}}Fields = map[expressions.FieldID]struct{}{
{{- range $name, $data := .FieldByFieldConstants}}
	{{$name}}: struct{}{},
{{- end}}
}
{{end}}

{{template "repository-interface" .}}
`))

	funcMap template.FuncMap = map[string]interface{}{
		"camelIdentifier": casing.CamelIdentifier,
		"toLower":         strings.ToLower,
	}

	_ = template.Must(repositoryTemplate.New("repository-interface").Funcs(funcMap).Parse(`
type {{.CRUD.Name}}Repository interface {
	{{if .CRUD.Create}}// Create creates new {{.CRUD.Name}}s.
	// Successfully created {{.CRUD.Name}}s are returned along with any errors that may have occurred.
	Create(context.Context, []*{{.CRUD.GoType .CRUD.File.GoPkg.Path}}) ([]*{{.CRUD.GoType .CRUD.File.GoPkg.Path}}, error)
	{{end}}
	{{if .CRUD.Read}}
	// Read returns a set of {{.CRUD.Name}}s matching the provided criteria
	// Read is incomplete and it should be considered unstable
	Read(context.Context, expressions.Expression) ([]*{{.CRUD.GoType .CRUD.File.GoPkg.Path}}, error)
	{{end}}
	{{if .CRUD.Update}}
	// Update modifies existing {{.CRUD.Name}}s based on the defined unique identifiers.
	// Successfully modified {{.CRUD.Name}}s are returned along with any errors that may have occurred.
	Update(context.Context, []*{{.CRUD.GoType .CRUD.File.GoPkg.Path}}) ([]*{{.CRUD.GoType .CRUD.File.GoPkg.Path}}, error)
	{{end}}
	{{if .CRUD.Delete}}
	// Delete deletes {{.CRUD.Name}}s matching the provided criteria
	// Delete is incomplete and it should be considered unstable
	Delete(context.Context,  expressions.Expression) error
	{{end}}
}
`))
)
