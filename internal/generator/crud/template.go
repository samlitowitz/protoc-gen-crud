// REFURL: https://github.com/grpc-ecosystem/grpc-gateway/blob/main/protoc-gen-grpc-gateway/internal/gengateway/template.go
package crud

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
	"text/template"

	"github.com/iancoleman/strcase"

	"github.com/samlitowitz/protoc-gen-crud/internal/casing"
	"github.com/samlitowitz/protoc-gen-crud/internal/descriptor"
)

func init() {
	strcase.ConfigureAcronym("UID", "uid")
}

func FieldIDConstantName(f *QueryableField) string {
	if !f.IsInlined {
		return fmt.Sprintf(
			"%s_%s_Field",
			strcase.ToCamel(f.Message.GetName()),
			strcase.ToCamel(f.GetName()),
		)
	}
	return fmt.Sprintf(
		"%s_%s_%s_Field",
		strcase.ToCamel(f.Parent.Message.GetName()),
		strcase.ToCamel(f.Parent.GetName()),
		strcase.ToCamel(f.GetName()),
	)
}

func FieldIDConstantValue(f *QueryableField) string {
	h := sha256.New()
	_, err := h.Write([]byte(FieldIDConstantName(f)))
	if err != nil {
		panic(err)
	}
	return hex.EncodeToString(h.Sum(nil))
}

type param struct {
	*descriptor.File
	Imports []descriptor.GoPackage
}

type message struct {
	*descriptor.Message
}

func applyTemplate(p param, reg *descriptor.Registry) (string, error) {
	w := bytes.NewBuffer(nil)
	if err := headerTemplate.Execute(w, p); err != nil {
		return "", err
	}

	for _, msg := range p.Messages {
		if !msg.GenerateCRUD {
			continue
		}
		if err := repositoryConstantsAndInterfaceTemplate.Execute(w, &message{msg}); err != nil {
			return "", err
		}
	}

	return w.String(), nil
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: {{.GetName}}

/*
Package {{.GoPkg.Name}} is a repository.

It provides an interface to implement.
*/

package {{.GoPkg.Name}}
{{if .Imports}}
import (
	{{range $i := .Imports}}{{if $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}

	{{range $i := .Imports}}{{if not $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}
)
{{end}}
`))

	funcMap template.FuncMap = map[string]interface{}{
		"camelIdentifier":            casing.CamelIdentifier,
		"toLower":                    strings.ToLower,
		"fieldIDConstantName":        FieldIDConstantName,
		"fieldIDConstantValue":       FieldIDConstantValue,
		"queryableFieldsFromMessage": QueryableFieldsFromMessage,
	}

	repositoryConstantsAndInterfaceTemplate = template.Must(template.New("repository-constants-and-interface").Funcs(funcMap).Parse(`
// These constants are used to specify fields in expressions
const (
{{- range $field := queryableFieldsFromMessage .Message}}
	{{fieldIDConstantName $field}} expressions.ID = "{{fieldIDConstantValue $field}}"
{{- end}}
)

var valid{{camelIdentifier .GetName}}Fields = map[expressions.ID]struct{}{
{{- range $field := queryableFieldsFromMessage .Message}}
	{{fieldIDConstantName $field}}: struct{}{},
{{- end}}
}

type {{.GetName}}Repository interface {
	// Create creates new {{.GetName}}s.
	// Successfully created {{.GetName}}s are returned along with any errors that may have occurred.
	Create(context.Context, []*{{.GoType .File.GoPkg.Path}}) ([]*{{.GoType .File.GoPkg.Path}}, error)

	// Read returns a set of {{.GetName}}s matching the provided criteria
	Read(context.Context, expressions.Expression) ([]*{{.GoType .File.GoPkg.Path}}, error)

	// Update modifies existing {{.GetName}}s based on the defined unique identifiers.
	// Successfully modified {{.GetName}}s are returned along with any errors that may have occurred.
	Update(context.Context, []*{{.GoType .File.GoPkg.Path}}) ([]*{{.GoType .File.GoPkg.Path}}, error)

	// Delete deletes {{.GetName}}s matching the provided criteria
	Delete(context.Context,  expressions.Expression) error
}
`))
)
