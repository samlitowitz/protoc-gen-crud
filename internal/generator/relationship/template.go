// REFURL: https://github.com/grpc-ecosystem/grpc-gateway/blob/main/protoc-gen-grpc-gateway/internal/gengateway/template.go
package relationship

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	crudOptions "github.com/samlitowitz/protoc-gen-crud/options"

	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/iancoleman/strcase"

	"github.com/samlitowitz/protoc-gen-crud/internal/descriptor"
)

func init() {
	strcase.ConfigureAcronym("UID", "uid")
}

type param struct {
	*descriptor.File
}

type relationshipParam struct {
	*descriptor.Relationship
}

func (r *relationshipParam) GetName() string {
	return r.DefinedOn.GetName() + r.With.GetName()
}

func (r *relationshipParam) Fields() []*descriptor.Field {
	return append(r.DefinedOn.PrimaryKey(), r.With.PrimaryKey()...)
}

func addOne(i int) int {
	return i + 1
}

func crudImplemenatationsAnnotation(r *relationshipParam) string {
	implsMap := make(map[crudOptions.Implementation]struct{}, len(r.DefinedOn.Implementations)+len(r.With.Implementations))
	impls := make([]string, 0, len(r.DefinedOn.Implementations)+len(r.With.Implementations))

	for impl := range r.DefinedOn.Implementations {
		if _, ok := implsMap[impl]; ok {
			continue
		}
		implsMap[impl] = struct{}{}
		impls = append(impls, impl.String())
	}
	for impl := range r.With.Implementations {
		if _, ok := implsMap[impl]; ok {
			continue
		}
		implsMap[impl] = struct{}{}
		impls = append(impls, impl.String())
	}

	return fmt.Sprintf("[%s]", strings.Join(impls, ", "))
}

func crudPrimaryKeyAnnotation(r *relationshipParam) string {
	fields := make([]string, 0, len(r.DefinedOn.PrimaryKey())+len(r.With.PrimaryKey()))

	for _, field := range r.DefinedOn.PrimaryKey() {
		fields = append(fields, `"`+protoFieldName(field)+`"`)
	}
	for _, field := range r.With.PrimaryKey() {
		fields = append(fields, `"`+protoFieldName(field)+`"`)
	}

	return fmt.Sprintf("[%s]", strings.Join(fields, ", "))
}

func protoFieldName(f *descriptor.Field) string {
	return strcase.ToLowerCamel(f.Message.GetName()) + "_" + f.GetName()
}

func protoType(f *descriptor.Field) string {
	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE:
		return "double"
	case descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		return "float"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "bool"

	case descriptorpb.FieldDescriptorProto_TYPE_UINT32:
		return "uint32"
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64:
		return "uint64"

	case descriptorpb.FieldDescriptorProto_TYPE_INT32:
		return "int32"
	case descriptorpb.FieldDescriptorProto_TYPE_FIXED32:
		return "fixed32"
	case descriptorpb.FieldDescriptorProto_TYPE_SINT32:
		return "sint32"

	case descriptorpb.FieldDescriptorProto_TYPE_INT64:
		return "int64"
	case descriptorpb.FieldDescriptorProto_TYPE_FIXED64:
		return "fixed64"
	case descriptorpb.FieldDescriptorProto_TYPE_SINT64:
		return "sint64"

	case descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "bytes"

	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return "string"

	case descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		typName := f.GetTypeName()
		if typName[0] == '.' {
			return typName[1:]
		}
		return typName

	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
		fallthrough
	case descriptorpb.FieldDescriptorProto_TYPE_GROUP:
		fallthrough
	default:
		panic(fmt.Sprintf("field %s: unsupported type %s", f.FQFN(), f.GetType()))
	}
}

func applyTemplate(p param, reg *descriptor.Registry) (string, error) {
	//return "", fmt.Errorf("%#v", p.GetDependency())

	w := bytes.NewBuffer(nil)
	if err := headerTemplate.Execute(w, p); err != nil {
		return "", err
	}

	for _, relationship := range p.Relationships {
		if err := protoMessageTemplate.Execute(w, &relationshipParam{relationship}); err != nil {
			return "", err
		}
	}

	return w.String(), nil
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: {{.GetName}}

syntax = "proto3";

package {{.GetPackage}};

option go_package = "{{.GoPkg.Path}}";

{{range $import := .GetDependency -}}
import "{{$import}}";
{{- end}}

import "{{.GetName}}";
`))

	funcMap template.FuncMap = map[string]interface{}{
		"addOne":              addOne,
		"crudImplementations": crudImplemenatationsAnnotation,
		"crudPrimaryKey":      crudPrimaryKeyAnnotation,
		"protoFieldName":      protoFieldName,
		"protoType":           protoType,
	}

	protoMessageTemplate = template.Must(template.New("proto-message").Funcs(funcMap).Parse(`
message {{.GetName}} {
  option (protoc_gen_crud.options.crud_message_options) = {
    implementations: {{crudImplementations .}}
    primaryKey: {{crudPrimaryKey .}}
  };
{{- range $i, $field := .Fields }}
  {{protoType $field}} {{protoFieldName $field}} = {{addOne $i}};
{{- end}}
}
`))
)
