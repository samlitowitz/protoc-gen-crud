package crud

import (
	"bytes"
	"fmt"
	"text/template"

	"github.com/samlitowitz/protoc-gen-crud/internal/generator/crud"

	crudOptions "github.com/samlitowitz/protoc-gen-crud/options"

	"github.com/samlitowitz/protoc-gen-crud/internal/casing"
	"github.com/samlitowitz/protoc-gen-crud/internal/descriptor"

	genPgSQL "github.com/samlitowitz/protoc-gen-crud/internal/generator/pgsql"

	"github.com/iancoleman/strcase"
)

func init() {
	strcase.ConfigureAcronym("UID", "uid")
}

func protoFieldAccessorFn(col *genPgSQL.Column) string {
	if col.AsTimestamp {
		return fmt.Sprintf("Get%s().AsTime()", casing.CamelIdentifier(col.GetName()))
	}
	if col.IsInlined {
		return fmt.Sprintf("Get%s().Get%s()", casing.CamelIdentifier(col.Parent.GetName()), casing.CamelIdentifier(col.Field.GetName()))
	}
	return fmt.Sprintf("Get%s()", casing.CamelIdentifier(col.GetName()))
}

func protoFieldField(col *genPgSQL.Column) string {
	if col.IsInlined {
		return fmt.Sprintf("Get%s().%s", casing.CamelIdentifier(col.Parent.GetName()), casing.CamelIdentifier(col.Field.GetName()))
	}
	return casing.CamelIdentifier(col.GetName())
}

func addI(a, b int) int {
	return a + b
}

type param struct {
	*descriptor.File
	Imports []descriptor.GoPackage
}

type message struct {
	*descriptor.Message

	QueryableCols         []*genPgSQL.Column
	PrimaryKeyCols        []*genPgSQL.Column
	NonPrimeAttributeCols []*genPgSQL.Column
}

func applyTemplate(p param, reg *descriptor.Registry) (string, error) {
	w := bytes.NewBuffer(nil)
	if err := headerTemplate.Execute(w, p); err != nil {
		return "", fmt.Errorf("header: %v", err)
	}

	for _, msg := range p.Messages {
		if !msg.GenerateCRUD {
			continue
		}
		if _, ok := msg.Implementations[crudOptions.Implementation_PGSQL]; !ok {
			continue
		}

		injected := &message{
			Message:               msg,
			QueryableCols:         genPgSQL.ColumnsFromFields(crud.QueryableFieldsFromMessage(msg)),
			PrimaryKeyCols:        genPgSQL.ColumnsFromFields(crud.QueryableFieldsFromFields(msg.PrimaryKey())),
			NonPrimeAttributeCols: genPgSQL.ColumnsFromFields(crud.QueryableFieldsFromFields(msg.NonPrimeAttributes())),
		}
		if err := repositoryTemplate.Execute(w, injected); err != nil {
			return "", fmt.Errorf(" message %s: repository: %v", msg.GetName(), err)
		}
	}

	return w.String(), nil
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: {{.GetName}}

/*
Package {{.GoPkg.Name}} is a repository.

PgSQL implementation.
*/

package {{.GoPkg.Name}}
{{if .Imports}}
import (
	{{range $i := .Imports}}{{if $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}

	{{range $i := .Imports}}{{if not $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}
)
{{end}}
`))

	repositoryTemplate = template.Must(template.New("repository").Parse(`
	{{template "repository-struct" .}}

	{{template "repository-create" .}}

	{{template "repository-read" .}}

	{{template "repository-update" .}}

	{{template "repository-delete" .}}

	{{template "repository-misc" .}}
	`))

	_ = template.Must(repositoryTemplate.New("repository-struct").Parse(`
// InMemory{{.GetName}}Repository is an in memory implementation of the {{.GetName}}Repository interface.
type PgSQL{{.GetName}}Repository struct {
	db *sql.DB
}

// NewInMemory creates a new InMemory{{.GetName}}Repository to be used.
func NewPgSQL{{.GetName}}Repository(db *sql.DB) (*PgSQL{{.GetName}}Repository, error) {
	_, ok := db.Driver().(*pgxstdlib.Driver)
	if !ok {
		return nil, fmt.Errorf("invalid driver, must be of type *github.com/jackc/pgx/v5/stdlib/Driver")
	}
	return &PgSQL{{.GetName}}Repository{
		db: db,
	}, nil
}
`))

	funcMap template.FuncMap = map[string]interface{}{
		"addI":            addI,
		"camelIdentifier": casing.CamelIdentifier,
		"toLowerCamel":    strcase.ToLowerCamel,

		"fieldIDConstantName":  crud.FieldIDConstantName,
		"fieldIDConstantValue": crud.FieldIDConstantValue,
		"protoFieldAccessor":   protoFieldAccessorFn,
		"protoFieldField":      protoFieldField,
		"sqlQuotedIdent":       genPgSQL.QuotedIdent,
		"sqlIdent":             genPgSQL.Ident,
	}

	_ = template.Must(repositoryTemplate.New("repository-create").Funcs(funcMap).Parse(`
// Create creates new {{.GetName}}s.
// Successfully created {{.GetName}}s are returned along with any errors that may have occurred.
func (repo *PgSQL{{.GetName}}Repository) Create(ctx context.Context, toCreate []*{{.GoType .File.GoPkg.Path}}) ([]*{{.GoType .File.GoPkg.Path}}, error) {
	if len(toCreate) == 0 {
		return nil, nil
	}
	tx, err := repo.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	{{- if .HasFieldMask -}}
	{{template "repository-create-field-mask" .}}
	{{- else -}}
	{{template "repository-create-no-field-mask" .}}
	{{- end -}}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return toCreate, nil
}
`))

	// TODO: Add support for in-line message types to these pieces
	_ = template.Must(repositoryTemplate.New("repository-create-no-field-mask").Funcs(funcMap).Parse(`
	binds := []any{}
	bindsStrs := []string{}
	bindsIdx := 1
	for _, {{toLowerCamel .GetName}} := range toCreate {
		{{- range $col := .QueryableCols}}
		binds = append(binds, {{toLowerCamel $.GetName}}.{{protoFieldAccessor $col}})
		{{- end}}
		bindsStrs = append(bindsStrs, fmt.Sprintf("(
			{{- range $i, $col := .QueryableCols -}}
			{{if $i}}, {{end}}$%d
			{{- end -}}
		)",
			{{- range $i, $col := .QueryableCols -}}
			{{if $i}},{{end}}bindsIdx + {{$i}}
			{{- end -}}
		))
		bindsIdx += {{len .QueryableCols}}
	}
	_, err = tx.ExecContext(
		ctx,
		fmt.Sprintf(
			` + "`" + `INSERT INTO {{sqlQuotedIdent .GetName}} (
			{{- range $i, $col := .QueryableCols -}}
				{{- if $i}},{{end}}{{sqlQuotedIdent $col.GetName}}
			{{- end -}}
			) VALUES
			%s` + "`" + `,
			strings.Join(bindsStrs, ",\n"),
		),
		binds...
	)
	if err != nil {
		return nil, err
	}
`))

	_ = template.Must(repositoryTemplate.New("repository-create-field-mask").Funcs(funcMap).Parse(`
	noMaskBinds := []any{}
	noMaskBindsStrs := []string{}
	noMaskBindsIdx := 1
	for _, {{toLowerCamel $.GetName}} := range toCreate {
		if {{toLowerCamel $.GetName}}.{{camelIdentifier $.FieldMask.GetName}} == nil {
			{{- range $col := .QueryableCols}}
			noMaskBinds = append(noMaskBinds, {{toLowerCamel $.GetName}}.{{protoFieldAccessor $col}})
			{{- end}}
			noMaskBindsStrs = append(noMaskBindsStrs, fmt.Sprintf("(
				{{- range $i, $col := .QueryableCols -}}
				{{if $i}}, {{end}}$%d
				{{- end -}}
			)",
				{{- range $i, $col := .QueryableCols -}}
				{{if $i}},{{end}}noMaskBindsIdx + {{$i}}
				{{- end -}}
			))
			noMaskBindsIdx += {{len .QueryableCols}}
			continue
		}
		valuesByColName, err := pgsql{{.GetName}}GetCreateValuesByColumnName({{toLowerCamel $.GetName}}, {{toLowerCamel $.GetName}}.{{camelIdentifier $.FieldMask.GetName}})
		if err != nil {
			return nil, err
		}
		if len(valuesByColName) == 0 {
			continue
		}
		var binds []any
		var cols []string
		var params []string
		paramsIdx := 1
		for colName, value := range valuesByColName {
			cols = append(cols, "\"" + colName + "\"")
			params = append(params, fmt.Sprintf("$%d", paramsIdx))
			paramsIdx += 1
			binds = append(binds, value)
		}
		query := fmt.Sprintf(` + "`" + `INSERT INTO {{sqlQuotedIdent .GetName}} (%s) VALUES (%s)` + "`" + `,
			strings.Join(cols, ", "),
			strings.Join(params, ", "),
		)
		_, err = tx.ExecContext(ctx, query, binds...)
		if err != nil {
			return nil, err
		}
	}
	if len(noMaskBinds) > 0 {
		query := fmt.Sprintf(` + "`" + `INSERT INTO {{sqlQuotedIdent .GetName}} (
			{{- range $i, $col := .QueryableCols -}}
			{{if $i}},{{end}}{{sqlQuotedIdent $col.GetName}}
			{{- end -}}
			) VALUES %s` + "`" + `,
			strings.Join(noMaskBindsStrs, ",\n"),
		)
		_, err = tx.ExecContext(ctx, query, noMaskBinds...)
		if err != nil {
			return nil, err
		}
	}
`))

	_ = template.Must(repositoryTemplate.New("repository-read").Funcs(funcMap).Parse(`
// Read returns a set of {{.GetName}}s matching the provided criteria
// Read is incomplete and it should be considered unstable
func (repo *PgSQL{{.GetName}}Repository) Read(ctx context.Context, expr expressions.Expression) ([]*{{.GoType .File.GoPkg.Path}}, error) {
	query := ` + "`" + `SELECT {{ range $i, $col := .QueryableCols -}}
		{{if $i}},{{end}}{{sqlQuotedIdent $col.GetName}}
		{{- end}}
		FROM {{sqlQuotedIdent .GetName -}}
` + "`" + `
	clauses, binds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr, 1)
	if err != nil {
		return nil, err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, binds...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var found []*{{.GoType .File.GoPkg.Path}}
	for rows.Next() {
		{{toLowerCamel .GetName}} := &{{.GoType .File.GoPkg.Path}}{
			{{range $i, $field := .NonPrimeAttributes -}}
			{{if $field.HasRelationship}}{{camelIdentifier $field.GetName}}: &{{$field.FieldMessage.GoType $.File.GoPkg.Path}}{},{{end}}
			{{if $field.Inline}}{{camelIdentifier $field.GetName}}: &{{$field.FieldMessage.GoType $.File.GoPkg.Path}}{},{{end}}
			{{- end}}
		}
		{{range $i, $field := .NonPrimeAttributes -}}
		{{if $field.AsTimestamp}}{{toLowerCamel $field.GetName}}Time := &pgtype.Timestamp{}{{end}}
		{{- end}}
		if err = rows.Scan(
		{{- range $i, $col := .QueryableCols -}}
		{{if $i}},{{end}}
		{{- if not $col.Field.AsTimestamp}} &{{toLowerCamel $.GetName}}.{{protoFieldField $col}} {{end -}}
		{{- if $col.Field.AsTimestamp}} &{{toLowerCamel $col.Field.GetName}}Time {{end -}}
		{{- end -}}
		); err != nil {
			return nil, err
		}
		{{ range $i, $col := .QueryableCols -}}
		{{ if $col.Field.AsTimestamp}}{{toLowerCamel $.GetName}}.{{protoFieldField $col}} = timestamppb.New({{toLowerCamel $col.Field.GetName}}Time.Time) {{end }}
		{{- end }}
		found = append(found, {{toLowerCamel .GetName}})
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}
	return found, nil
}
`))

	_ = template.Must(repositoryTemplate.New("repository-update").Funcs(funcMap).Parse(`
// Update modifies existing {{.GetName}}s based on the defined unique identifiers.
func (repo *PgSQL{{.GetName}}Repository) Update(ctx context.Context, toUpdate []*{{.GoType .File.GoPkg.Path}}) ([]*{{.GoType .File.GoPkg.Path}}, error) {
	{{- if eq (len .NonPrimeAttributes) 0 -}}
	return nil, nil
	{{- else -}}
	if len(toUpdate) == 0 {
		return nil, nil
	}
	tx, err := repo.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare(
		` + "`" + `UPDATE {{sqlQuotedIdent .GetName}} SET {{range $i, $col := .NonPrimeAttributeCols -}}
		{{if $i}},{{end}}{{sqlQuotedIdent $col.GetName}} = ${{addI $i 1}}
		{{- end }} WHERE {{ range $i, $cols := .PrimaryKeyCols -}}
		{{if $i}} AND {{end}}{{sqlQuotedIdent $cols.GetName}} = ${{addI (addI $i (len $.NonPrimeAttributeCols)) 1}}
		{{- end }}` + "`" + `,
	)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	{{- if .HasFieldMask -}}
	{{ template "repository-update-field-mask" .}}
	{{- else -}}
	{{ template "repository-update-no-field-mask" .}}
	{{- end -}}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return toUpdate, nil
	{{- end -}}
}
`))

	_ = template.Must(repositoryTemplate.New("repository-update-no-field-mask").Funcs(funcMap).Parse(`
	for _, {{toLowerCamel .GetName}} := range toUpdate {
		_, err = stmt.ExecContext(ctx, {{ range $i, $col := .NonPrimeAttributeCols -}}
		{{if $i}},{{end}}{{toLowerCamel $.GetName}}.{{protoFieldAccessor $col}}
		{{- end }},{{ range $i, $col := .PrimaryKeyCols -}}
		{{if $i}},{{end}}{{toLowerCamel $.GetName}}.{{protoFieldAccessor $col}}
		{{- end }})
		if err != nil {
			return nil, err
		}
	}
`))

	_ = template.Must(repositoryTemplate.New("repository-update-field-mask").Funcs(funcMap).Parse(`
	for _, {{toLowerCamel .GetName}} := range toUpdate {
		if {{toLowerCamel .GetName}}.{{camelIdentifier .FieldMask.GetName}} == nil {
			_, err = stmt.ExecContext(ctx, {{ range $i, $col := .NonPrimeAttributeCols -}}
			{{if $i}},{{end}}{{toLowerCamel $.GetName}}.{{protoFieldAccessor $col}}
			{{- end }},{{ range $i, $col := .PrimaryKeyCols -}}
			{{if $i}},{{end}}{{toLowerCamel $.GetName}}.{{protoFieldAccessor $col}}
			{{- end }})
			if err != nil {
				return nil, err
			}
			continue
		}
		valuesByColName, err := pgsql{{.GetName}}GetUpdateValuesByColumnName({{toLowerCamel .GetName}}, {{toLowerCamel .GetName}}.{{camelIdentifier .FieldMask.GetName}})
		if err != nil {
			return nil, err
		}
		if len(valuesByColName) == 0 {
			continue
		}
		var binds []any
		bindsIdx := 1
		var setStmts []string
		for colName, value := range valuesByColName {
			setStmts = append(setStmts, fmt.Sprintf("\"%s\" = $%d", colName, bindsIdx))
			bindsIdx += 1
			binds = append(binds, value)
		}
		_, err = tx.ExecContext(
			ctx,
			fmt.Sprintf(
				` + "`" + `UPDATE {{sqlQuotedIdent .GetName}} SET %s WHERE {{ range $i, $col := .PrimaryKeyCols -}}
				{{if $i}} AND {{end}}{{sqlQuotedIdent $col.GetName}} = $%d
				{{- end }}` + "`" + `,
				strings.Join(setStmts, ", "),
				{{ range $i, $col := .PrimaryKeyCols -}}
				bindsIdx + {{$i}},
				{{- end }}
			),
			append(
				binds,
				{{ range $i, $field := .PrimaryKeyCols -}}
				{{if $i}},{{end}}{{toLowerCamel $.GetName}}.Get{{camelIdentifier $field.GetName}}()
				{{- end }},
			)...
		)
		if err != nil {
			return nil, err
		}
	}
`))

	_ = template.Must(repositoryTemplate.New("repository-delete").Funcs(funcMap).Parse(`
// Delete deletes {{.GetName}}s based on the defined unique identifiers
func (repo *PgSQL{{.GetName}}Repository) Delete(ctx context.Context, expr expressions.Expression) error {
	query := ` + "`" + `DELETE FROM {{sqlQuotedIdent .GetName}}` + "`" + `
	clauses, binds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr, 1)
	if err != nil {
		return err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return err
	}
	_, err = stmt.ExecContext(ctx, binds...)
	if err != nil {
		return err
	}
	return nil
}
`))

	_ = template.Must(repositoryTemplate.New("repository-misc").Funcs(funcMap).Parse(`
var pgsql{{.GetName}}ColumnNameByFieldID = map[expressions.FieldID]string{
{{- range $col := .QueryableCols}}
	{{fieldIDConstantName $col.QueryableField}}: "{{sqlIdent $col.GetName}}",
{{- end}}
}

func whereClauseFromExpressionForPgSQL{{.GetName}}(expr expressions.Expression, paramIdx int) (string, []any, error) {
	if expr == nil {
		return "", nil, nil
	}
	switch expr := expr.(type) {
		case *expressions.And:
			left, leftBinds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr.Left(), paramIdx)
			if err != nil {
				return "", nil, err
			}
			right, rightBinds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr.Right(), paramIdx + len(leftBinds))
			if err != nil {
				return "", nil, err
			}
			return fmt.Sprintf("%s AND %s", left, right), append(leftBinds, rightBinds...), nil

		case *expressions.Or:
				left, leftBinds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr.Left(), paramIdx)
			if err != nil {
				return "", nil, err
			}
			right, rightBinds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr.Right(), paramIdx + len(leftBinds))
			if err != nil {
				return "", nil, err
			}
			return fmt.Sprintf("%s OR %s", left, right), append(leftBinds, rightBinds...), nil
		case *expressions.Not:
			operand, binds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr.Operand(), paramIdx)
			if err != nil {
				return "", nil, err
			}
			return fmt.Sprintf("NOT %s", operand), binds, nil

		case *expressions.Equal:
				left, leftBinds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr.Left(), paramIdx)
			if err != nil {
				return "", nil, err
			}
			right, rightBinds, err := whereClauseFromExpressionForPgSQL{{.GetName}}(expr.Right(), paramIdx + len(leftBinds))
			if err != nil {
				return "", nil, err
			}
			return fmt.Sprintf("%s = %s", left, right), append(leftBinds, rightBinds...), nil

		case *expressions.Identifier:
			if _, ok := valid{{.GetName}}Fields[expr.ID()]; !ok {
				return "", nil, fmt.Errorf("invalid field id: %s", expr.ID())
			}
			colName, ok := pgsql{{.GetName}}ColumnNameByFieldID[expr.ID()]
			if !ok {
				return "", nil, fmt.Errorf("missing meta-data: field id: %s", expr.ID())
			}
			return fmt.Sprintf(` + "`" + `{{sqlQuotedIdent .GetName}}."%s"` + "`" + `,colName), nil, nil
		case *expressions.Scalar:
			return fmt.Sprintf("$%d", paramIdx), []any{expr.Value()}, nil
		case expressions.Timestamp:
			return fmt.Sprintf("$%d", paramIdx), []any{time.Time(expr)}, nil
		default:
			return "", nil, fmt.Errorf("unknown expression")
	}
}

{{if .HasFieldMask}}
func pgsql{{.GetName}}GetCreateValuesByColumnName(def *{{.GoType .File.GoPkg.Path}}, fieldMask *fieldmaskpb.FieldMask) (map[string]any, error) {
	if fieldMask == nil {
		return nil, fmt.Errorf("no field mask provided")
	}
	{{toLowerCamel $.GetName}} := &{{.GoType .File.GoPkg.Path}}{}
	valuesByColumnName := make(map[string]any, 0)
	nestedMask := fmutils.NestedMaskFromPaths(fieldMask.Paths)
	{{ range $i, $col := .PrimaryKeyCols -}}
	if _, ok := nestedMask["{{$col.Field.GetName}}"]; !ok {
		return nil, fmt.Errorf("primary key field excluded by field mask: {{$col.Field.GetName}}")
	}
	valuesByColumnName["{{sqlIdent $col.Field.GetName}}"] = def.{{protoFieldAccessor $col}}
	{{end -}}
	{{ range $i, $col := .NonPrimeAttributeCols -}}
	if _, ok := nestedMask["{{$col.Field.GetName}}"]; ok {
		valuesByColumnName["{{sqlIdent $col.Field.GetName}}"] = def.{{protoFieldAccessor $col}}
	} else {
		valuesByColumnName["{{sqlIdent $col.Field.GetName}}"] = {{toLowerCamel $.GetName}}.{{protoFieldAccessor $col}}
	}
	{{end -}}
	return valuesByColumnName, nil
}
func pgsql{{.GetName}}GetUpdateValuesByColumnName(def *{{.GoType .File.GoPkg.Path}}, fieldMask *fieldmaskpb.FieldMask) (map[string]any, error) {
	if fieldMask == nil {
		return nil, fmt.Errorf("no field mask provided")
	}
	valuesByColumnName := make(map[string]any, 0)
	nestedMask := fmutils.NestedMaskFromPaths(fieldMask.Paths)
	{{ range $i, $col := .PrimaryKeyCols -}}
	if _, ok := nestedMask["{{$col.Field.GetName}}"]; !ok {
		return nil, fmt.Errorf("primary key field excluded by field mask: {{$col.Field.GetName}}")
	}
	{{end -}}
	{{ range $i, $col := .NonPrimeAttributeCols -}}
	if _, ok := nestedMask["{{$col.Field.GetName}}"]; ok {
		valuesByColumnName["{{sqlIdent $col.GetName}}"] = def.{{protoFieldAccessor $col}}
	}
	{{end -}}
	return valuesByColumnName, nil
}
{{end}}
`))
)
