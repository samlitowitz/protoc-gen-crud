// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: protoc-gen-crud/examples/link-via-unique-id-single/user.proto

/*
Package link_via_unique_id_single is a repository.

It provides an interface to implement and some implementations of the interface.
*/

package link_via_unique_id_single

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/mennanov/fmutils"
	"github.com/samlitowitz/protoc-gen-crud/expressions"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
	"modernc.org/sqlite"
)

const (
	User_FieldMask_Field expressions.FieldID = "7efcc4b1e37ccfd27abf0900cfc133cb96e6eeb09c785a67cbab74c701acb02c"
	User_Id_Field        expressions.FieldID = "441df8206d64f0e4cf6ad874026ceab109b6b0d2262387c2273ed1d80973589f"
	User_Password_Field  expressions.FieldID = "fcf0b45269d1e8a2cc0c5c9d3d6013283791fb304e4022200c908dfb41da4019"
	User_Profile_Field   expressions.FieldID = "5e25e6f951dfc1b02b565d5eeebc15a257f69f351e187d7f06096849065ac10b"
	User_Username_Field  expressions.FieldID = "3a893c049a89f5736a021eebc001470079160c4bb5e213e8913b73108d67ba6a"
)

var validUserFields = map[expressions.FieldID]struct{}{
	User_FieldMask_Field: struct{}{},
	User_Id_Field:        struct{}{},
	User_Password_Field:  struct{}{},
	User_Profile_Field:   struct{}{},
	User_Username_Field:  struct{}{},
}

// InMemoryUserRepository is an in memory implementation of the UserRepository interface.
type SQLiteUserRepository struct {
	db *sql.DB
}

// NewInMemory creates a new InMemoryUserRepository to be used.
func NewSQLiteUserRepository(db *sql.DB) (*SQLiteUserRepository, error) {
	_, ok := db.Driver().(*sqlite.Driver)
	if !ok {
		return nil, fmt.Errorf("invalid driver, must be of type *modernc.org/sqlite.Driver")
	}
	return &SQLiteUserRepository{
		db: db,
	}, nil
}

// Create creates new Users.
// Successfully created Users are returned along with any errors that may have occurred.
func (repo *SQLiteUserRepository) Create(ctx context.Context, toCreate []*User) ([]*User, error) {
	if len(toCreate) == 0 {
		return nil, nil
	}
	tx, err := repo.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	noMaskBinds := []any{}
	noMaskBindsStrs := []string{}
	for _, user := range toCreate {
		if user.FieldMask == nil {
			noMaskBinds = append(noMaskBinds, user.GetId())
			noMaskBinds = append(noMaskBinds, user.GetUsername())
			noMaskBinds = append(noMaskBinds, user.GetPassword())
			noMaskBinds = append(noMaskBinds, user.GetProfile())
			noMaskBindsStrs = append(noMaskBindsStrs, "(?,?,?,?)")
			continue
		}
		valuesByColName, err := sqliteUserGetCreateValuesByColumnName(user, user.FieldMask)
		if err != nil {
			return nil, err
		}
		if len(valuesByColName) == 0 {
			continue
		}
		var binds []any
		var cols []string
		var params []string
		for colName, value := range valuesByColName {
			cols = append(cols, "\""+colName+"\"")
			params = append(params, "?")
			binds = append(binds, value)
		}
		_, err = tx.ExecContext(
			ctx,
			fmt.Sprintf(
				"INSERT INTO \"user\" (%s) VALUES \n (%s)",
				strings.Join(cols, ", "),
				strings.Join(params, ", "),
			),
			binds...,
		)
		if err != nil {
			return nil, err
		}
	}
	if len(noMaskBinds) > 0 {
		_, err = tx.ExecContext(
			ctx,
			fmt.Sprintf(
				"INSERT INTO \"user\" (\"id\",\"username\",\"password\",\"profile\") VALUES \n %s",
				strings.Join(noMaskBindsStrs, ",\n"),
			),
			noMaskBinds...,
		)
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return toCreate, nil
}

// Read returns a set of Users matching the provided criteria
// Read is incomplete and it should be considered unstable
func (repo *SQLiteUserRepository) Read(ctx context.Context, expr expressions.Expression) ([]*User, error) {
	query := "SELECT \"id\",\"username\",\"password\",\"profile\" FROM \"user\""
	clauses, binds, err := whereClauseFromExpressionForUser(expr)
	if err != nil {
		return nil, err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, binds...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var found []*User
	for rows.Next() {
		user := &User{}
		if err = rows.Scan(&user.Id, &user.Username, &user.Password, &user.Profile); err != nil {
			return nil, err
		}
		found = append(found, user)
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}
	return found, nil
}

// Update modifies existing Users based on the defined unique identifiers.
func (repo *SQLiteUserRepository) Update(ctx context.Context, toUpdate []*User) ([]*User, error) {

	if len(toUpdate) == 0 {
		return nil, nil
	}
	tx, err := repo.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare(
		"UPDATE \"user\" SET \"username\" = ?,\"password\" = ?,\"profile\" = ? WHERE \"id\" = ?",
	)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	for _, user := range toUpdate {
		if user.FieldMask == nil {
			_, err = stmt.ExecContext(ctx, user.GetUsername(), user.GetPassword(), user.GetProfile(), user.GetId())
			if err != nil {
				return nil, err
			}
			continue
		}
		valuesByColName, err := sqliteUserGetUpdateValuesByColumnName(user, user.FieldMask)
		if err != nil {
			return nil, err
		}
		if len(valuesByColName) == 0 {
			continue
		}
		var binds []any
		var setStmts []string
		for colName, value := range valuesByColName {
			setStmts = append(setStmts, fmt.Sprintf("\"%s\" = ?", colName))
			binds = append(binds, value)
		}
		_, err = tx.ExecContext(
			ctx,
			fmt.Sprintf(
				"UPDATE \"user\" SET %s WHERE \"id\" = ?",
				strings.Join(setStmts, ", "),
			),
			append(
				binds,
				user.GetId(),
			)...,
		)
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return toUpdate, nil

}

// Delete deletes Users based on the defined unique identifiers
func (repo *SQLiteUserRepository) Delete(ctx context.Context, expr expressions.Expression) error {
	query := "DELETE FROM \"user\""
	clauses, binds, err := whereClauseFromExpressionForUser(expr)
	if err != nil {
		return err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return err
	}
	_, err = stmt.ExecContext(ctx, binds...)
	if err != nil {
		return err
	}
	return nil
}

var sqliteUserColumnNameByFieldID = map[expressions.FieldID]string{
	User_FieldMask_Field: "field_mask",
	User_Id_Field:        "id",
	User_Password_Field:  "password",
	User_Profile_Field:   "profile",
	User_Username_Field:  "username",
}

func whereClauseFromExpressionForUser(expr expressions.Expression) (string, []any, error) {
	if expr == nil {
		return "", nil, nil
	}
	switch expr := expr.(type) {
	case *expressions.And:
		left, leftBinds, err := whereClauseFromExpressionForUser(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForUser(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s AND %s", left, right), append(leftBinds, rightBinds...), nil

	case *expressions.Or:
		left, leftBinds, err := whereClauseFromExpressionForUser(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForUser(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s OR %s", left, right), append(leftBinds, rightBinds...), nil
	case *expressions.Not:
		operand, binds, err := whereClauseFromExpressionForUser(expr.Operand())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("NOT %s", operand), binds, nil

	case *expressions.Equal:
		left, leftBinds, err := whereClauseFromExpressionForUser(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForUser(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s = %s", left, right), append(leftBinds, rightBinds...), nil

	case *expressions.Identifier:
		if _, ok := validUserFields[expr.ID()]; !ok {
			return "", nil, fmt.Errorf("invalid field id: %s", expr.ID())
		}
		colName, ok := sqliteUserColumnNameByFieldID[expr.ID()]
		if !ok {
			return "", nil, fmt.Errorf("missing meta-data: field id: %s", expr.ID())
		}
		return fmt.Sprintf("\"user\".\"%s\"", colName), nil, nil

	case *expressions.Scalar:
		return "?", []any{expr.Value()}, nil
	default:
		return "", nil, fmt.Errorf("unknown expression")
	}
}

func sqliteUserGetCreateValuesByColumnName(def *User, fieldMask *fieldmaskpb.FieldMask) (map[string]any, error) {
	if fieldMask == nil {
		return nil, fmt.Errorf("no field mask provided")
	}
	user := &User{}
	valuesByColumnName := make(map[string]any, 0)
	nestedMask := fmutils.NestedMaskFromPaths(fieldMask.Paths)
	if _, ok := nestedMask["id"]; ok {
		valuesByColumnName["id"] = def.GetId()
	} else {
		valuesByColumnName["id"] = user.GetId()
	}
	if _, ok := nestedMask["username"]; ok {
		valuesByColumnName["username"] = def.GetUsername()
	} else {
		valuesByColumnName["username"] = user.GetUsername()
	}
	if _, ok := nestedMask["password"]; ok {
		valuesByColumnName["password"] = def.GetPassword()
	} else {
		valuesByColumnName["password"] = user.GetPassword()
	}
	if _, ok := nestedMask["profile"]; ok {
		valuesByColumnName["profile"] = def.GetProfile()
	} else {
		valuesByColumnName["profile"] = user.GetProfile()
	}
	return valuesByColumnName, nil
}
func sqliteUserGetUpdateValuesByColumnName(def *User, fieldMask *fieldmaskpb.FieldMask) (map[string]any, error) {
	if fieldMask == nil {
		return nil, fmt.Errorf("no field mask provided")
	}
	valuesByColumnName := make(map[string]any, 0)
	nestedMask := fmutils.NestedMaskFromPaths(fieldMask.Paths)
	if _, ok := nestedMask["id"]; ok {
		valuesByColumnName["id"] = def.GetId()
	}
	if _, ok := nestedMask["username"]; ok {
		valuesByColumnName["username"] = def.GetUsername()
	}
	if _, ok := nestedMask["password"]; ok {
		valuesByColumnName["password"] = def.GetPassword()
	}
	if _, ok := nestedMask["profile"]; ok {
		valuesByColumnName["profile"] = def.GetProfile()
	}
	return valuesByColumnName, nil
}

const (
	Profile_FieldMask_Field expressions.FieldID = "ba64be71eee94b079d268405865d06b4bbfb1b1a21be85227db0f838226b6d1a"
	Profile_Id_Field        expressions.FieldID = "919879b873a9b2f968f40a30a49067f0f72f92982c5eb60f753ea21a2dad1a60"
	Profile_Name_Field      expressions.FieldID = "d42e181493d40c3a5a552762626660fa4262b558643ed92cd73590ee3642cade"
)

var validProfileFields = map[expressions.FieldID]struct{}{
	Profile_FieldMask_Field: struct{}{},
	Profile_Id_Field:        struct{}{},
	Profile_Name_Field:      struct{}{},
}

// InMemoryProfileRepository is an in memory implementation of the ProfileRepository interface.
type SQLiteProfileRepository struct {
	db *sql.DB
}

// NewInMemory creates a new InMemoryProfileRepository to be used.
func NewSQLiteProfileRepository(db *sql.DB) (*SQLiteProfileRepository, error) {
	_, ok := db.Driver().(*sqlite.Driver)
	if !ok {
		return nil, fmt.Errorf("invalid driver, must be of type *modernc.org/sqlite.Driver")
	}
	return &SQLiteProfileRepository{
		db: db,
	}, nil
}

// Create creates new Profiles.
// Successfully created Profiles are returned along with any errors that may have occurred.
func (repo *SQLiteProfileRepository) Create(ctx context.Context, toCreate []*Profile) ([]*Profile, error) {
	if len(toCreate) == 0 {
		return nil, nil
	}
	tx, err := repo.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	noMaskBinds := []any{}
	noMaskBindsStrs := []string{}
	for _, profile := range toCreate {
		if profile.FieldMask == nil {
			noMaskBinds = append(noMaskBinds, profile.GetId())
			noMaskBinds = append(noMaskBinds, profile.GetName())
			noMaskBindsStrs = append(noMaskBindsStrs, "(?,?)")
			continue
		}
		valuesByColName, err := sqliteProfileGetCreateValuesByColumnName(profile, profile.FieldMask)
		if err != nil {
			return nil, err
		}
		if len(valuesByColName) == 0 {
			continue
		}
		var binds []any
		var cols []string
		var params []string
		for colName, value := range valuesByColName {
			cols = append(cols, "\""+colName+"\"")
			params = append(params, "?")
			binds = append(binds, value)
		}
		_, err = tx.ExecContext(
			ctx,
			fmt.Sprintf(
				"INSERT INTO \"profile\" (%s) VALUES \n (%s)",
				strings.Join(cols, ", "),
				strings.Join(params, ", "),
			),
			binds...,
		)
		if err != nil {
			return nil, err
		}
	}
	if len(noMaskBinds) > 0 {
		_, err = tx.ExecContext(
			ctx,
			fmt.Sprintf(
				"INSERT INTO \"profile\" (\"id\",\"name\") VALUES \n %s",
				strings.Join(noMaskBindsStrs, ",\n"),
			),
			noMaskBinds...,
		)
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return toCreate, nil
}

// Read returns a set of Profiles matching the provided criteria
// Read is incomplete and it should be considered unstable
func (repo *SQLiteProfileRepository) Read(ctx context.Context, expr expressions.Expression) ([]*Profile, error) {
	query := "SELECT \"id\",\"name\" FROM \"profile\""
	clauses, binds, err := whereClauseFromExpressionForProfile(expr)
	if err != nil {
		return nil, err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, binds...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var found []*Profile
	for rows.Next() {
		profile := &Profile{}
		if err = rows.Scan(&profile.Id, &profile.Name); err != nil {
			return nil, err
		}
		found = append(found, profile)
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}
	return found, nil
}

// Update modifies existing Profiles based on the defined unique identifiers.
func (repo *SQLiteProfileRepository) Update(ctx context.Context, toUpdate []*Profile) ([]*Profile, error) {

	if len(toUpdate) == 0 {
		return nil, nil
	}
	tx, err := repo.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	stmt, err := tx.Prepare(
		"UPDATE \"profile\" SET \"name\" = ? WHERE \"id\" = ?",
	)
	if err != nil {
		return nil, err
	}
	defer stmt.Close()

	for _, profile := range toUpdate {
		if profile.FieldMask == nil {
			_, err = stmt.ExecContext(ctx, profile.GetName(), profile.GetId())
			if err != nil {
				return nil, err
			}
			continue
		}
		valuesByColName, err := sqliteProfileGetUpdateValuesByColumnName(profile, profile.FieldMask)
		if err != nil {
			return nil, err
		}
		if len(valuesByColName) == 0 {
			continue
		}
		var binds []any
		var setStmts []string
		for colName, value := range valuesByColName {
			setStmts = append(setStmts, fmt.Sprintf("\"%s\" = ?", colName))
			binds = append(binds, value)
		}
		_, err = tx.ExecContext(
			ctx,
			fmt.Sprintf(
				"UPDATE \"profile\" SET %s WHERE \"id\" = ?",
				strings.Join(setStmts, ", "),
			),
			append(
				binds,
				profile.GetId(),
			)...,
		)
		if err != nil {
			return nil, err
		}
	}

	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return toUpdate, nil

}

// Delete deletes Profiles based on the defined unique identifiers
func (repo *SQLiteProfileRepository) Delete(ctx context.Context, expr expressions.Expression) error {
	query := "DELETE FROM \"profile\""
	clauses, binds, err := whereClauseFromExpressionForProfile(expr)
	if err != nil {
		return err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return err
	}
	_, err = stmt.ExecContext(ctx, binds...)
	if err != nil {
		return err
	}
	return nil
}

var sqliteProfileColumnNameByFieldID = map[expressions.FieldID]string{
	Profile_FieldMask_Field: "field_mask",
	Profile_Id_Field:        "id",
	Profile_Name_Field:      "name",
}

func whereClauseFromExpressionForProfile(expr expressions.Expression) (string, []any, error) {
	if expr == nil {
		return "", nil, nil
	}
	switch expr := expr.(type) {
	case *expressions.And:
		left, leftBinds, err := whereClauseFromExpressionForProfile(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForProfile(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s AND %s", left, right), append(leftBinds, rightBinds...), nil

	case *expressions.Or:
		left, leftBinds, err := whereClauseFromExpressionForProfile(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForProfile(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s OR %s", left, right), append(leftBinds, rightBinds...), nil
	case *expressions.Not:
		operand, binds, err := whereClauseFromExpressionForProfile(expr.Operand())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("NOT %s", operand), binds, nil

	case *expressions.Equal:
		left, leftBinds, err := whereClauseFromExpressionForProfile(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForProfile(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s = %s", left, right), append(leftBinds, rightBinds...), nil

	case *expressions.Identifier:
		if _, ok := validProfileFields[expr.ID()]; !ok {
			return "", nil, fmt.Errorf("invalid field id: %s", expr.ID())
		}
		colName, ok := sqliteProfileColumnNameByFieldID[expr.ID()]
		if !ok {
			return "", nil, fmt.Errorf("missing meta-data: field id: %s", expr.ID())
		}
		return fmt.Sprintf("\"profile\".\"%s\"", colName), nil, nil

	case *expressions.Scalar:
		return "?", []any{expr.Value()}, nil
	default:
		return "", nil, fmt.Errorf("unknown expression")
	}
}

func sqliteProfileGetCreateValuesByColumnName(def *Profile, fieldMask *fieldmaskpb.FieldMask) (map[string]any, error) {
	if fieldMask == nil {
		return nil, fmt.Errorf("no field mask provided")
	}
	profile := &Profile{}
	valuesByColumnName := make(map[string]any, 0)
	nestedMask := fmutils.NestedMaskFromPaths(fieldMask.Paths)
	if _, ok := nestedMask["id"]; ok {
		valuesByColumnName["id"] = def.GetId()
	} else {
		valuesByColumnName["id"] = profile.GetId()
	}
	if _, ok := nestedMask["name"]; ok {
		valuesByColumnName["name"] = def.GetName()
	} else {
		valuesByColumnName["name"] = profile.GetName()
	}
	return valuesByColumnName, nil
}
func sqliteProfileGetUpdateValuesByColumnName(def *Profile, fieldMask *fieldmaskpb.FieldMask) (map[string]any, error) {
	if fieldMask == nil {
		return nil, fmt.Errorf("no field mask provided")
	}
	valuesByColumnName := make(map[string]any, 0)
	nestedMask := fmutils.NestedMaskFromPaths(fieldMask.Paths)
	if _, ok := nestedMask["id"]; ok {
		valuesByColumnName["id"] = def.GetId()
	}
	if _, ok := nestedMask["name"]; ok {
		valuesByColumnName["name"] = def.GetName()
	}
	return valuesByColumnName, nil
}
