// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: protoc-gen-crud/examples/simple/simple.proto

/*
Package simple is a repository.

It provides an interface to implement and some implementations of the interface.
*/

package simple

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/samlitowitz/protoc-gen-crud/expressions"
	"modernc.org/sqlite"
)

const (
	User_Id_Field       expressions.FieldID = "441df8206d64f0e4cf6ad874026ceab109b6b0d2262387c2273ed1d80973589f"
	User_Password_Field expressions.FieldID = "fcf0b45269d1e8a2cc0c5c9d3d6013283791fb304e4022200c908dfb41da4019"
	User_Username_Field expressions.FieldID = "3a893c049a89f5736a021eebc001470079160c4bb5e213e8913b73108d67ba6a"
)

var validUserFields = map[expressions.FieldID]struct{}{
	User_Id_Field:       struct{}{},
	User_Password_Field: struct{}{},
	User_Username_Field: struct{}{},
}

// InMemoryUserRepository is an in memory implementation of the UserRepository interface.
type SQLiteUserRepository struct {
	db *sql.DB
}

// NewInMemory creates a new InMemoryUserRepository to be used.
func NewSQLiteUserRepository(db *sql.DB) (*SQLiteUserRepository, error) {
	_, ok := db.Driver().(*sqlite.Driver)
	if !ok {
		return nil, fmt.Errorf("invalid driver, must be of type *modernc.org/sqlite.Driver")
	}
	return &SQLiteUserRepository{
		db: db,
	}, nil
}

// Create creates new Users.
// Successfully created Users are returned along with any errors that may have occurred.
func (repo *SQLiteUserRepository) Create(ctx context.Context, toCreate []*User) ([]*User, error) {
	if len(toCreate) == 0 {
		return nil, nil
	}
	binds := []any{}
	bindsStrs := []string{}
	for _, val := range toCreate {
		binds = append(binds, val.Id)
		binds = append(binds, val.Username)
		binds = append(binds, val.Password)
		bindsStrs = append(bindsStrs, "(?, ?, ?)")
	}
	query := fmt.Sprintf(
		"INSERT INTO \"user\" (\"id\", \"username\", \"password\") VALUES\n%s",
		strings.Join(bindsStrs, ",\n"),
	)
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return nil, err
	}
	_, err = stmt.ExecContext(ctx, binds...)
	if err != nil {
		return nil, err
	}
	return toCreate, nil

}

// Read returns a set of Users matching the provided criteria
// Read is incomplete and it should be considered unstable
func (repo *SQLiteUserRepository) Read(ctx context.Context, expr expressions.Expression) ([]*User, error) {
	query := "SELECT \"id\", \"username\", \"password\"\nFROM \"user\""
	clauses, binds, err := whereClauseFromExpressionForUser(expr)
	if err != nil {
		return nil, err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, binds...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var found []*User
	for rows.Next() {
		user := &User{}
		if err = rows.Scan(&user.Id, &user.Username, &user.Password); err != nil {
			return nil, err
		}
		found = append(found, user)
	}
	if err = rows.Err(); err != nil {
		return nil, err
	}
	return found, nil
}

// Update modifies existing Users based on the defined unique identifiers.
func (repo *SQLiteUserRepository) Update(ctx context.Context, toUpdate []*User) ([]*User, error) {
	if len(toUpdate) == 0 {
		return nil, nil
	}
	tx, err := repo.db.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()
	stmt, err := tx.Prepare("UPDATE \"user\"\nSET \"id\" = ?, \"username\" = ?, \"password\" = ?\nWHERE \"id\" = ?")
	if err != nil {
		return nil, err
	}
	defer stmt.Close()
	for _, user := range toUpdate {
		_, err = stmt.ExecContext(ctx, user.Id, user.Username, user.Password, user.Id)
		if err != nil {
			return nil, err
		}
	}
	err = tx.Commit()
	if err != nil {
		return nil, err
	}
	return toUpdate, nil

}

// Delete deletes Users based on the defined unique identifiers
func (repo *SQLiteUserRepository) Delete(ctx context.Context, expr expressions.Expression) error {
	query := "DELETE FROM \"user\""
	clauses, binds, err := whereClauseFromExpressionForUser(expr)
	if err != nil {
		return err
	}
	if clauses != "" {
		query += "\nWHERE\n" + clauses
	}
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return err
	}
	_, err = stmt.ExecContext(ctx, binds...)
	if err != nil {
		return err
	}
	return nil
}

var sqliteUserFieldMetaData = map[expressions.FieldID]struct {
	tableName  string
	columnName string
}{
	User_Id_Field: {
		tableName:  "user",
		columnName: "id",
	},
	User_Password_Field: {
		tableName:  "user",
		columnName: "password",
	},
	User_Username_Field: {
		tableName:  "user",
		columnName: "username",
	},
}

func whereClauseFromExpressionForUser(expr expressions.Expression) (string, []any, error) {
	if expr == nil {
		return "", nil, nil
	}
	switch expr := expr.(type) {
	case *expressions.And:
		left, leftBinds, err := whereClauseFromExpressionForUser(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForUser(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s AND %s", left, right), append(leftBinds, rightBinds...), nil

	case *expressions.Or:
		left, leftBinds, err := whereClauseFromExpressionForUser(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForUser(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s OR %s", left, right), append(leftBinds, rightBinds...), nil
	case *expressions.Not:
		operand, binds, err := whereClauseFromExpressionForUser(expr.Operand())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("NOT %s", operand), binds, nil

	case *expressions.Equal:
		left, leftBinds, err := whereClauseFromExpressionForUser(expr.Left())
		if err != nil {
			return "", nil, err
		}
		right, rightBinds, err := whereClauseFromExpressionForUser(expr.Right())
		if err != nil {
			return "", nil, err
		}
		return fmt.Sprintf("%s = %s", left, right), append(leftBinds, rightBinds...), nil

	case *expressions.Identifier:
		if _, ok := validUserFields[expr.ID()]; !ok {
			return "", nil, fmt.Errorf("invalid field id: %s", expr.ID())
		}
		metaData, ok := sqliteUserFieldMetaData[expr.ID()]
		if !ok {
			return "", nil, fmt.Errorf("missing meta-data: field id: %s", expr.ID())
		}
		return fmt.Sprintf(
			"\"%s\".\"%s\"",
			metaData.tableName,
			metaData.columnName,
		), nil, nil

	case *expressions.Scalar:
		return "?", []any{expr.Value()}, nil
	default:
		return "", nil, fmt.Errorf("unknown expression")
	}
}
