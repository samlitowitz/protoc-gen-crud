// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: protoc-gen-crud/examples/simple/simple.proto

/*
Package simple is a repository.

It provides an interface to implement and some implementations of the interface.
*/

package simple

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/samlitowitz/protoc-gen-crud/expressions"
	"modernc.org/sqlite"
)

const (
	User_Id_Field       expressions.FieldID = "441df8206d64f0e4cf6ad874026ceab109b6b0d2262387c2273ed1d80973589f"
	User_Password_Field expressions.FieldID = "fcf0b45269d1e8a2cc0c5c9d3d6013283791fb304e4022200c908dfb41da4019"
	User_Username_Field expressions.FieldID = "3a893c049a89f5736a021eebc001470079160c4bb5e213e8913b73108d67ba6a"
)

var validUserFields = map[expressions.FieldID]struct{}{
	User_Id_Field:       struct{}{},
	User_Password_Field: struct{}{},
	User_Username_Field: struct{}{},
}

type UserRepository interface {
	// Create creates new Users.
	// Successfully created Users are returned along with any errors that may have occurred.
	Create(context.Context, []*User) ([]*User, error)

	// Read returns a set of Users matching the provided criteria
	// Read is incomplete and it should be considered unstable
	Read(context.Context, expressions.Expression) ([]*User, error)

	// Update modifies existing Users based on the defined unique identifiers.
	// Successfully modified Users are returned along with any errors that may have occurred.
	Update(context.Context, []*User) ([]*User, error)

	// Delete deletes Users matching the provided criteria
	// Delete is incomplete and it should be considered unstable
	Delete(context.Context, expressions.Expression) error
}

// InMemoryUserRepository is an in memory implementation of the UserRepository interface.
type InMemoryUserRepository struct {
	userById map[string]uint
	iTable   map[uint]*User
	next     uint
}

// NewInMemory creates a new InMemoryUserRepository to be used.
func NewInMemoryUserRepository() *InMemoryUserRepository {
	return &InMemoryUserRepository{
		userById: make(map[string]uint),
		iTable:   make(map[uint]*User),
	}
}

// Create creates new Users.
// Successfully created Users are returned along with any errors that may have occurred.
func (repo *InMemoryUserRepository) Create(ctx context.Context, toCreate []*User) ([]*User, error) {
	indicesToCreate := make(map[uint]*User)

	indexById, idByIndex, userById, err := buildUserIdMap(toCreate)
	if err != nil {
		return nil, err
	}
	for key, val := range userById {
		if _, ok := indexById[key]; !ok {
			// internal error, should never happen
			continue
		}
		if _, ok := idByIndex[indexById[key]]; !ok {
			// internal error, should never happen
			continue

		}
		if _, ok := repo.userById[key]; ok {
			// add error about duplicate
			delete(indicesToCreate, indexById[key])
			continue
		}
		if _, ok := indicesToCreate[indexById[key]]; !ok {
			// mark index as to be created
			indicesToCreate[indexById[key]] = val
		}
	}

	created := make([]*User, 0, len(indicesToCreate))
	for i, val := range indicesToCreate {
		repo.iTable[repo.next] = val
		repo.userById[idByIndex[i]] = repo.next
		created = append(created, val)
		repo.next++
	}
	return created, nil
}

// Read returns a set of Users matching the provided criteria
// Read is incomplete and it should be considered unstable
func (repo *InMemoryUserRepository) Read(ctx context.Context, expr expressions.Expression) ([]*User, error) {
	found := make([]*User, 0, len(repo.iTable))

	for _, user := range repo.iTable {
		include, err := testExprOnUser(user, expr)
		if err != nil {
			return nil, err
		}
		if !include {
			continue
		}
		found = append(found, user)
	}
	return found, nil
}

// Update modifies existing Users based on the defined unique identifiers.
func (repo *InMemoryUserRepository) Update(ctx context.Context, toUpdate []*User) ([]*User, error) {
	indicesToUpdate := make(map[uint]uint)

	indexById, idByIndex, userById, err := buildUserIdMap(toUpdate)
	if err != nil {
		return nil, err
	}
	for key, _ := range userById {
		if _, ok := indexById[key]; !ok {
			// internal error, should never happen
			continue
		}
		if _, ok := idByIndex[indexById[key]]; !ok {
			// internal error, should never happen
			continue

		}
		if _, ok := repo.userById[key]; !ok {
			// add error about missing
			delete(indicesToUpdate, indexById[key])
			continue
		}
		if _, ok := indicesToUpdate[indexById[key]]; ok {
			continue
		}
		// mark index as to be created
		indicesToUpdate[indexById[key]] = repo.userById[idByIndex[indexById[key]]]
	}

	updated := make([]*User, 0, len(indicesToUpdate))
	for i, j := range indicesToUpdate {
		repo.iTable[j] = toUpdate[i]
		updated = append(updated, toUpdate[i])
	}
	return updated, nil
}

// Delete deletes Users matching the provided criteria
// Delete is incomplete and it should be considered unstable
func (repo *InMemoryUserRepository) Delete(ctx context.Context, expr expressions.Expression) error {
	indicesToDelete := make(map[uint]struct{})
	toDelete := []*User{}

	for i, user := range repo.iTable {
		include, err := testExprOnUser(user, expr)
		if err != nil {
			return err
		}
		if !include {
			continue
		}
		indicesToDelete[i] = struct{}{}
		toDelete = append(toDelete, user)
	}

	_, idByIndex, _, err := buildUserIdMap(toDelete)
	if err != nil {
		return err
	}

	for i, _ := range indicesToDelete {
		// remove iTable entry indexed by userById
		delete(repo.iTable, repo.userById[idByIndex[i]])
		// remove {hash, iTable index} from userById
		delete(repo.userById, idByIndex[i])
		delete(repo.iTable, i)
	}
	return nil
}

func testExprOnUser(user *User, expr expressions.Expression) (bool, error) {
	if user == nil {
		return false, nil
	}
	if expr == nil {
		return true, nil
	}
	switch expr := expr.(type) {
	case *expressions.And:
		left, err := testExprOnUser(user, expr.Left())
		if err != nil {
			return true, err
		}
		right, err := testExprOnUser(user, expr.Right())
		if err != nil {
			return true, err
		}
		return left && right, nil

	case *expressions.Or:
		left, err := testExprOnUser(user, expr.Left())
		if err != nil {
			return true, err
		}
		right, err := testExprOnUser(user, expr.Right())
		if err != nil {
			return true, err
		}
		return left || right, nil
	case *expressions.Not:
		operand, err := testExprOnUser(user, expr.Operand())
		if err != nil {
			return true, err
		}
		return !operand, nil

	case *expressions.Equal:
		result, err := testEqualExprOnUser(user, expr)
		if err != nil {
			return true, err
		}
		return result, nil

	case *expressions.Identifier:
		return true, fmt.Errorf("identifiers and scalar values are only supported as operands of the equal expression")
	case *expressions.Scalar:
		return true, fmt.Errorf("identifiers and scalar values are only supported as operands of the equal expression")
	default:
		return true, fmt.Errorf("unknown expression")
	}
}

func testEqualExprOnUser(user *User, expr *expressions.Equal) (bool, error) {
	var ident *expressions.Identifier
	var scalar *expressions.Scalar

	left := expr.Left()
	switch left := left.(type) {
	case *expressions.Identifier:
		if _, ok := validUserFields[left.ID()]; !ok {
			return true, fmt.Errorf("invalid field id: %s", left.ID())
		}
		ident = left
	case *expressions.Scalar:
		scalar = left
	default:
		return true, fmt.Errorf("left operand must an identifier or a scalar value")
	}

	right := expr.Right()
	switch right := right.(type) {
	case *expressions.Identifier:
		if ident != nil {
			return true, fmt.Errorf("left operand is an identifier, right operand must be a scalar value")
		}
		ident = right
	case *expressions.Scalar:
		if scalar != nil {
			return true, fmt.Errorf("left operand is an scalar value, right operand must be an identifier")
		}
		scalar = right
	default:
		return true, fmt.Errorf("right operand must an scalar value or an identifier")
	}
	switch ident.ID() {
	case User_Id_Field:
		typedVal, ok := any(scalar.Value()).(string)
		if !ok {
			return true, fmt.Errorf(
				"invalid type on field user.Id: expected type string: got value %#v",
				scalar.Value(),
			)
		}
		return user.Id == typedVal, nil
	case User_Password_Field:
		typedVal, ok := any(scalar.Value()).(string)
		if !ok {
			return true, fmt.Errorf(
				"invalid type on field user.Password: expected type string: got value %#v",
				scalar.Value(),
			)
		}
		return user.Password == typedVal, nil
	case User_Username_Field:
		typedVal, ok := any(scalar.Value()).(string)
		if !ok {
			return true, fmt.Errorf(
				"invalid type on field user.Username: expected type string: got value %#v",
				scalar.Value(),
			)
		}
		return user.Username == typedVal, nil
	}
	return false, nil
}

func buildUserIdMap(users []*User) (
	map[string]uint,
	map[uint]string,
	map[string]*User,
	error,
) {
	indexById := make(map[string]uint)
	idByIndex := make(map[uint]string)
	userById := make(map[string]*User)

	for i, def := range users {
		indexById[def.Id] = uint(i)
		idByIndex[uint(i)] = def.Id
		userById[def.Id] = def
	}

	return indexById, idByIndex, userById, nil
}

// InMemoryUserRepository is an in memory implementation of the UserRepository interface.
type SQLiteUserRepository struct {
	db *sql.DB
}

// NewInMemory creates a new InMemoryUserRepository to be used.
func NewSQLiteUserRepository(db *sql.DB) (*SQLiteUserRepository, error) {
	_, ok := db.Driver().(*sqlite.Driver)
	if !ok {
		return nil, fmt.Errorf("invalid driver, must be of type *modernc.org/sqlite.Driver")
	}
	return &SQLiteUserRepository{
		db: db,
	}, nil
}

// Create creates new Users.
// Successfully created Users are returned along with any errors that may have occurred.
func (repo *SQLiteUserRepository) Create(ctx context.Context, toCreate []*User) ([]*User, error) {
	if len(toCreate) == 0 {
		return nil, nil
	}
	binds := []any{}
	bindsStrs := []string{}
	for i, val := range toCreate {
		binds = append(
			binds,
			sql.Named(
				fmt.Sprintf(":user_id_field_%d", i),
				val.Id,
			),
		)
		bindsStrs = append(bindsStrs, fmt.Sprintf(":user_id_field_%d", i))
		binds = append(
			binds,
			sql.Named(
				fmt.Sprintf(":user_password_field_%d", i),
				val.Password,
			),
		)
		bindsStrs = append(bindsStrs, fmt.Sprintf(":user_password_field_%d", i))
		binds = append(
			binds,
			sql.Named(
				fmt.Sprintf(":user_username_field_%d", i),
				val.Username,
			),
		)
		bindsStrs = append(bindsStrs, fmt.Sprintf(":user_username_field_%d", i))
	}
	query := fmt.Sprintf(
		"INSERT INTO `user` (`id`, `username`, `password`) VALUES\n%s",
		strings.Join(bindsStrs, ",\n"),
	)
	stmt, err := repo.db.Prepare(query)
	if err != nil {
		return nil, err
	}
	_, err = stmt.Exec(binds...)
	if err != nil {
		return nil, err
	}
	// TODO: WIP
	return nil, nil
}

// Read returns a set of Users matching the provided criteria
// Read is incomplete and it should be considered unstable
func (repo *SQLiteUserRepository) Read(ctx context.Context, expr expressions.Expression) ([]*User, error) {
	panic("not implemented")
}

// Update modifies existing Users based on the defined unique identifiers.
func (repo *SQLiteUserRepository) Update(ctx context.Context, toUpdate []*User) ([]*User, error) {
	panic("not implemented")
}

// Delete deletes Users based on the defined unique identifiers
func (repo *SQLiteUserRepository) Delete(ctx context.Context, toDelete []*User) error {
	panic("not implemented")
}
