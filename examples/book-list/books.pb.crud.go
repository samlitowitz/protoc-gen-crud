// Code generated by protoc-gen-go-crud. DO NOT EDIT.
// source: protoc-gen-crud/assets/protobuf/examples/book-list/books.proto

/*
Package book_list is a repository.

It provides an interface to implement and some implementations of the interface.
*/

package book_list

import (
	"crypto/sha256"
	"encoding/binary"
)

type AuthorRepository interface {
	// Create creates new Authors.
	// Successfully created Authors are returned along with any errors that may have occurred.
	Create([]*Author) ([]*Author, error)

	// Read returns a set of Authors matching the provided criteria
	// Read is incomplete and it should be considered unstable
	// Use where clauses
	Read() ([]*Author, error)

	// Update modifies existing Authors based on the defined unique identifiers.
	// Successfully modified Authors are returned along with any errors that may have occurred.
	Update([]*Author) ([]*Author, error)

	// Delete deletes Authors based on the defined unique identifiers
	// Delete is incomplete and it should be considered unstable
	// Use where clauses
	Delete([]*Author) error
}

// InMemoryAuthorRepository is an in memory implementation of the AuthorRepository interface.
type InMemoryAuthorRepository struct {
	authorById     map[string]*Author
	authorByIdName map[string]*Author
}

// NewInMemory creates a new InMemoryAuthorRepository to be used.
func NewInMemoryAuthorRepository() *InMemoryAuthorRepository {
	return &InMemoryAuthorRepository{
		authorById:     make(map[string]*Author),
		authorByIdName: make(map[string]*Author),
	}
}

// Create creates new Authors.
// Successfully created Authors are returned along with any errors that may have occurred.
func (repo *InMemoryAuthorRepository) Create(toCreate []*Author) ([]*Author, error) {
	indicesToCreate := make(map[int]*Author)

	indexById, idByIndex, authorById, err := buildIdMap(toCreate)
	if err != nil {
		return nil, err
	}
	for key, val := range authorById {
		if _, ok := indexById[key]; !ok {
			// internal error, should never happen
			continue
		}
		if _, ok := idByIndex[indexById[key]]; !ok {
			// internal error, should never happen
			continue

		}
		if _, ok := repo.authorById[key]; ok {
			// add error about duplicate
			delete(indicesToCreate, indexById[key])
			continue
		}
		if _, ok := indicesToCreate[indexById[key]]; !ok {
			// mark index as to be created
			indicesToCreate[indexById[key]] = val
		}
	}

	indexByIdName, idNameByIndex, authorByIdName, err := buildIdNameMap(toCreate)
	if err != nil {
		return nil, err
	}
	for key, val := range authorByIdName {
		if _, ok := indexByIdName[key]; !ok {
			// internal error, should never happen
			continue
		}
		if _, ok := idNameByIndex[indexByIdName[key]]; !ok {
			// internal error, should never happen
			continue

		}
		if _, ok := repo.authorByIdName[key]; ok {
			// add error about duplicate
			delete(indicesToCreate, indexByIdName[key])
			continue
		}
		if _, ok := indicesToCreate[indexByIdName[key]]; !ok {
			// mark index as to be created
			indicesToCreate[indexByIdName[key]] = val
		}
	}

	created := make([]*Author, 0, len(indicesToCreate))
	for i, val := range indicesToCreate {
		repo.authorById[idByIndex[i]] = val
		repo.authorByIdName[idNameByIndex[i]] = val
		created = append(created, val)
	}
	return created, nil
}

// Read returns a set of Authors matching the provided criteria
// Read is incomplete and it should be considered unstable
// Use where clauses
func (repo *InMemoryAuthorRepository) Read() ([]*Author, error) {
	panic("not implemented")
}

// Update modifies existing Authors based on the defined unique identifiers.
func (repo *InMemoryAuthorRepository) Update([]*Author) ([]*Author, error) {
	panic("not implemented")
}

// Delete deletes Authors based on the defined unique identifiers
func (repo *InMemoryAuthorRepository) Delete(toDelete []*Author) error {
	indicesToDelete := make(map[int]struct{})

	indexById, idByIndex, authorById, err := buildIdMap(toDelete)
	if err != nil {
		return err
	}
	for key, _ := range authorById {
		if _, ok := indexById[key]; !ok {
			// internal error, should never happen
			continue
		}
		if _, ok := idByIndex[indexById[key]]; !ok {
			// internal error, should never happen
			continue

		}
		if _, ok := repo.authorById[key]; ok {
			// add error about duplicate
			delete(indicesToDelete, indexById[key])
			continue
		}
		if _, ok := indicesToDelete[indexById[key]]; !ok {
			// mark index as to be created
			indicesToDelete[indexById[key]] = struct{}{}
		}
	}

	indexByIdName, idNameByIndex, authorByIdName, err := buildIdNameMap(toDelete)
	if err != nil {
		return err
	}
	for key, _ := range authorByIdName {
		if _, ok := indexByIdName[key]; !ok {
			// internal error, should never happen
			continue
		}
		if _, ok := idNameByIndex[indexByIdName[key]]; !ok {
			// internal error, should never happen
			continue

		}
		if _, ok := repo.authorByIdName[key]; ok {
			// add error about duplicate
			delete(indicesToDelete, indexByIdName[key])
			continue
		}
		if _, ok := indicesToDelete[indexByIdName[key]]; !ok {
			// mark index as to be created
			indicesToDelete[indexByIdName[key]] = struct{}{}
		}
	}

	for i, _ := range indicesToDelete {
		delete(repo.authorById, idByIndex[i])
		delete(repo.authorByIdName, idNameByIndex[i])
	}
	return nil
}

func buildIdMap(authors []*Author) (
	map[string]int,
	map[int]string,
	map[string]*Author,
	error,
) {
	indexById := make(map[string]int)
	idByIndex := make(map[int]string)
	authorById := make(map[string]*Author)

	for i, def := range authors {
		indexById[def.Id] = i
		idByIndex[i] = def.Id
		authorById[def.Id] = def
	}

	return indexById, idByIndex, authorById, nil
}

func buildIdNameMap(authors []*Author) (
	map[string]int,
	map[int]string,
	map[string]*Author,
	error,
) {
	indexByIdName := make(map[string]int)
	idNameByIndex := make(map[int]string)
	authorByIdName := make(map[string]*Author)

	var err error
	h := sha256.New()
	for i, def := range authors {
		err = binary.Write(h, binary.LittleEndian, "{{")
		if err != nil {
			return nil, nil, nil, err
		}
		err = binary.Write(h, binary.LittleEndian, def.Id)
		if err != nil {
			return nil, nil, nil, err
		}
		err = binary.Write(h, binary.LittleEndian, "}}")
		if err != nil {
			return nil, nil, nil, err
		}
		err = binary.Write(h, binary.LittleEndian, "{{")
		if err != nil {
			return nil, nil, nil, err
		}
		err = binary.Write(h, binary.LittleEndian, def.Name)
		if err != nil {
			return nil, nil, nil, err
		}
		err = binary.Write(h, binary.LittleEndian, "}}")
		if err != nil {
			return nil, nil, nil, err
		}

		key := string(h.Sum(nil))
		indexByIdName[key] = i
		idNameByIndex[i] = key
		authorByIdName[key] = def
		h.Reset()
	}

	return indexByIdName, idNameByIndex, authorByIdName, nil
}

type BookRepository interface {
}
